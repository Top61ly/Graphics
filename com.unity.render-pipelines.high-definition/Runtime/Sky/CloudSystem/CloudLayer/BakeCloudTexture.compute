#pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch

#pragma multi_compile_local _ USE_SECOND_CLOUD_LAYER

#pragma kernel BakeCloudTexture KERNEL_NAME=BakeCloudTexture
//#pragma enable_d3d11_debug_symbols

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/VolumeRendering.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/SkyUtils.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/PhysicallyBasedSky/PhysicallyBasedSkyCommon.hlsl"

#ifndef USE_SECOND_CLOUD_LAYER
    #define NUM_LAYERS  1
    #define LAYER       0
#else
    #define NUM_LAYERS  2
    #define LAYER       dispatchThreadId.z
#endif

// The number of octaves for the multi-scattering
#define NUM_MULTI_SCATTERING_OCTAVES 2
// Forward eccentricity
#define FORWARD_ECCENTRICITY 0.7
// Forward eccentricity
#define BACKWARD_ECCENTRICITY 0.7

TEXTURE2D(_CloudMapA);
SAMPLER(sampler_CloudMapA);

#ifdef USE_SECOND_CLOUD_LAYER
TEXTURE2D(_CloudMapB);
SAMPLER(sampler_CloudMapB);
#endif

RW_TEXTURE2D_ARRAY(float2, _CloudTexture);

float4 _Params;
float4 _Params1[NUM_LAYERS];
float4 _Params2[NUM_LAYERS];
float4 _Params3[NUM_LAYERS];

#define _SunDirection       _Params.xyz
#define _UpperHemisphere    (_Params.w > 0)
#define _Opacities          _Params1[data.index]
#define _Rotation           _Params2[LAYER].x
#define _LightingSteps      _Params2[data.index].y
#define _Thickness          _Params2[data.index].z
#define _Resolution         _Params2[0].w
#define _LowestCloudAltitude _Params3[data.index].x
#define _MultiScattering     _Params3[data.index].y
#define _SigmaT              _Params3[data.index].z

#define _EarthRadius 6378100.0f

struct LayerSamplingData
{
    int index;
    float4 weights;

    TEXTURE2D(cloudMap);
    SAMPLER(sampler_cloudMap);
};

void GetCloudVolumeIntersection(LayerSamplingData data, float3 dir, out float rangeStart, out float range)
{
    float _HighestCloudAltitude = _LowestCloudAltitude + _Thickness, rangeEnd;

    rangeStart = -IntersectSphere(_LowestCloudAltitude + _EarthRadius, -dir.y, _EarthRadius).x;
    rangeEnd = -IntersectSphere(_HighestCloudAltitude + _EarthRadius, -dir.y, _EarthRadius).x;
    range = rangeEnd - rangeStart;
}
float GetCloudVolumeIntersection_Light(LayerSamplingData data, float3 originWS, float3 dir)
{
    float _HighestCloudAltitude = _LowestCloudAltitude + _Thickness;

    float3 startPS = originWS + float3(0, _EarthRadius, 0);
    float lenStartPS = length(startPS), rcpLenStartPS = rcp(lenStartPS);
    float cosChi = dot(-dir, startPS * rcpLenStartPS);
   return -IntersectSphere(_HighestCloudAltitude + _EarthRadius, cosChi, lenStartPS, rcpLenStartPS).x;
}

float3 InverseLatLong(float2 uv, float upperHemisphereOnly)
{
    const float2 invAtan = float2(0.1591, 0.3183);

    uv.y = upperHemisphereOnly ? uv.y * 0.5 + 0.5 : uv.y;
    uv = (uv - 0.5) / invAtan;

    float y = sin(uv.y);
    float scale = sqrt(1.0 - y*y);

    return float3(sin(uv.x) * scale, y, cos(uv.x) * scale);
}

float SampleCloudMap(LayerSamplingData data, float2 uv)
{
    float4 cloudLayerColor = SAMPLE_TEXTURE2D_LOD(data.cloudMap, data.sampler_cloudMap, uv, 0);

    float4 clouds = cloudLayerColor * data.weights;
    return clouds.r + clouds.g + clouds.b + clouds.a;
}

float3 RotationUp(float3 p, float2 cos_sin)
{
    float3 rotDirX = float3(cos_sin.x, 0, -cos_sin.y);
    float3 rotDirY = float3(cos_sin.y, 0,  cos_sin.x);

    return float3(dot(rotDirX, p), p.y, dot(rotDirY, p));
}

float GetDensity(LayerSamplingData data, float3 positionWS, float3 dir, float thickness)
{
    float rangeStart = _LowestCloudAltitude, range = _Thickness;
    GetCloudVolumeIntersection(data, dir, rangeStart, range);

    float distToCenter = length(dir * (rangeStart + 0.5 * range) - positionWS);
    float density = 1 - saturate(distToCenter / (range * thickness));
    return density * thickness;
}

float GetDensity(LayerSamplingData data, float3 positionWS)
{
    float3 dir = normalize(positionWS);
    float thickness = SampleCloudMap(data, GetLatLongCoords(dir, _UpperHemisphere));
    return GetDensity(data, positionWS, dir, thickness);
}

float EvaluateSunLuminance(LayerSamplingData data, float3 positionWS, float phaseFunction[NUM_MULTI_SCATTERING_OCTAVES])
{
    const int _NumLightSteps = (int)_LightingSteps;

    float luminance = 0.0, extinction = 0.0;
    float totalLightDistance = GetCloudVolumeIntersection_Light(data, positionWS, _SunDirection);
    totalLightDistance = clamp(totalLightDistance, 0, 1000);

    // Compute the size of the current step
    float stepSize = totalLightDistance / (float)_NumLightSteps;

    // Collect total density along light ray.
    for (int j = 1; j <= _NumLightSteps; j++)
    {
        float3 currentSamplePointWS = positionWS + _SunDirection * stepSize * j;
        extinction += GetDensity(data, currentSamplePointWS);
    }

    // Combine the luminance for each octave
    for (int o = 0; o < NUM_MULTI_SCATTERING_OCTAVES; ++o)
        luminance += exp(-stepSize * extinction * _SigmaT * PositivePow(_MultiScattering, o))
                     * phaseFunction[o]
                     * PositivePow(_MultiScattering, o);

    return luminance;
}

float2 ComputeCloudLighting(TEXTURE2D(cloudMap), SAMPLER(sampler_cloudMap), float2 uv, uint index)
{
    LayerSamplingData data;

    data.index = index;
    data.cloudMap = cloudMap;
    data.sampler_cloudMap = sampler_cloudMap;
    data.weights = _Opacities / max(_Opacities.r + _Opacities.g + _Opacities.b + _Opacities.a, 1.0);

    const float opacity = SampleCloudMap(data, uv);
    float2 finalColor = opacity;

    if ((int)_LightingSteps != 0)
    {
        const float3 dir = InverseLatLong(uv, _UpperHemisphere);
        const float cosAngle = dot(dir, _SunDirection);

        float phaseFunction[NUM_MULTI_SCATTERING_OCTAVES];
        for (int o = 0; o < NUM_MULTI_SCATTERING_OCTAVES; ++o)
        {
            const float forwardP = HenyeyGreenstein(cosAngle, FORWARD_ECCENTRICITY * PositivePow(_MultiScattering, o));
            const float backwardsP = HenyeyGreenstein(cosAngle, -BACKWARD_ECCENTRICITY * PositivePow(_MultiScattering, o));
            phaseFunction[o] = backwardsP + forwardP;
        }

        float rangeStart, range;
        GetCloudVolumeIntersection(data, dir, rangeStart, range);

        float3 currentPositionWS = dir * (rangeStart + 0.5 * (1 - opacity) * range);
        range *= opacity;

        finalColor = 0;
        float density = GetDensity(data, currentPositionWS, dir, opacity);
        if (density != 0.0f)
        {
            const float currentStepExtinction = exp(-density * _SigmaT * range);
            const float luminance = EvaluateSunLuminance(data, currentPositionWS, phaseFunction);

            finalColor.x = (luminance - luminance * currentStepExtinction);
            finalColor.y = opacity;
        }
    }

    return finalColor;
}

[numthreads(8, 8, NUM_LAYERS)]
void KERNEL_NAME(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    float2 uv = float2(dispatchThreadId.x * _Resolution, dispatchThreadId.y * _Resolution);
    if (_UpperHemisphere)
        uv.y *= 2.0f;

#ifndef USE_SECOND_CLOUD_LAYER
    float2 cloudLayerColor = ComputeCloudLighting(_CloudMapA, sampler_CloudMapA, uv, LAYER);
#else
    float2 cloudLayerColor = LAYER == 0 ?
        ComputeCloudLighting(_CloudMapA, sampler_CloudMapA, uv, LAYER) :
        ComputeCloudLighting(_CloudMapB, sampler_CloudMapB, uv, LAYER);
#endif

    dispatchThreadId.x = frac(uv.x + _Rotation) / _Resolution;
    _CloudTexture[dispatchThreadId] = cloudLayerColor;
}
